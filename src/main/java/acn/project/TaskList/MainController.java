package acn.project.TaskList;

import java.io.IOException;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import javax.validation.Valid;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.opencsv.bean.CsvToBean;
import com.opencsv.bean.CsvToBeanBuilder;
import com.opencsv.bean.HeaderColumnNameMappingStrategy;

@Controller // This means that this class is a Controller
@RequestMapping(path = "/tasklist") // This means URL's start with /tasklist (after Application path)

public class MainController 
{
	@Autowired // This means to get the bean called taskRepository
	// Which is auto-generated by Spring, we will use it to handle the data
	
	private TaskRepository taskRepository;

	// Display list of task
	@GetMapping("/all")
	public String index(Model model) {
		List<Task> tasks = (List<Task>) taskRepository.findAll();
		for (Task task : tasks) 
		{
		}
		model.addAttribute("tasks", tasks);
		return "index";
	}

	// Add Task
	@RequestMapping(value = "/add")
	public String addTask(Model model) {
		model.addAttribute("task", new Task());
		return "addTask";
	}

	// Save Task
	@RequestMapping(value = "save", method = RequestMethod.POST)
	public String save(@Valid Task task, BindingResult bindingResult) {
		if (bindingResult.hasErrors()) {
			return "addTask";
		}
		taskRepository.save(task);
		return "redirect:/tasklist/all";
	}

	// Delete Task
	@RequestMapping(value = "/delete/{taskId}", method = RequestMethod.GET)
	public String deleteTask(@PathVariable("taskId") Long taskId, Model model) {
		taskRepository.delete(taskId);
		return "redirect:/tasklist/all";
	}

	// Update Task
	@RequestMapping(value = { "update/{taskId}" }, method = RequestMethod.GET)
	public String update(Model model, @PathVariable("taskId") String taskId) {
		if (taskId != null) 
		{
			model.addAttribute("task", taskRepository.findOne(Long.valueOf(taskId)));
		} 
		else 
		{
			model.addAttribute("task", new Task());
		}
		return "updateTask";
	}

	@RequestMapping(value = "update/save/{taskId}", method = RequestMethod.GET)
	public String updateTask(@PathVariable("taskId") String taskId, @Valid Task task, BindingResult bindingResult,
			Model model) {
		if (bindingResult.hasErrors()) {
			return "updateTask";
		}
		task.setTaskId(Long.valueOf(taskId));
		taskRepository.save(task);
		model.addAttribute("task", taskRepository.findAll());
		return "redirect:/tasklist/all";
	}

	// Save the uploaded file to this folder
	private static String UPLOADED_FOLDER = "C:\\Users\\Lenovo\\Desktop\\uploaded files";

	// Upload file
	@RequestMapping(value = "/upload", method = RequestMethod.POST)
	public String singleFileUpload(@RequestParam("myFile") MultipartFile myFile,
			RedirectAttributes redirectAttributes) {

		if (myFile.isEmpty()) {
			redirectAttributes.addFlashAttribute("message", "Please select a file to upload");
			return "redirect:/tasklist/uploadStatus";
		}

		try {
			// Get the file and save it somewhere
			byte[] bytes = myFile.getBytes();
			Path path = Paths.get(UPLOADED_FOLDER + myFile.getOriginalFilename());
			Files.write(path, bytes);

			/*redirectAttributes.addFlashAttribute("message",
					"You successfully uploaded '" + myFile.getOriginalFilename() + "'");*/

			try (Reader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) 
			{
				// The HeaderColumnNameMappingStrategy maps data to objects using the column
				// names in the first row of the CSV file.
				HeaderColumnNameMappingStrategy<Task> strategy = new HeaderColumnNameMappingStrategy<>();
				strategy.setType(Task.class);

				// A CsvToBean is created with CsvToBeanBuilder. We specify the type and the
				// mapping strategy.
				CsvToBean<Task> csvToBean = new CsvToBeanBuilder<Task>(reader).withType(Task.class)
						.withMappingStrategy(strategy).withIgnoreLeadingWhiteSpace(true).build();

				// CsvToBean's parse() method, we parse the CSV data into the list.
				List<Task> tasks = csvToBean.parse();
				taskRepository.save(tasks);
			}

		} catch (IOException e) {
			e.printStackTrace();

		}

		return "redirect:/tasklist/all";
	}

	@RequestMapping(value = "/uploadStatus", method = RequestMethod.GET)
	public String uploadStatus() {
		return "uploadStatus";
	}

	
	  // @ResponseBody means the returned String is the response, not a view name
	  // @RequestParam means it is a parameter from the GET or POST request
	 
		/*@GetMapping(path="/add") // Map ONLY GET Requests 
	  public @ResponseBody String addNewTask (@RequestParam String taskName , @RequestParam String technologyUsed, 
	  @RequestParam String description , @RequestParam String
	  startDate, @RequestParam String completionDate, @RequestParam String status, 
	  @RequestParam String review, @RequestParam String remarks) 
	 	
	 {
	  Task n = new Task(); 
	  n.setTaskName(taskName);
	  n.setTechnologyUsed(technologyUsed); 
	  n.setDescription(description);
	  n.setStartDate(startDate); 
	  n.setCompletionDate(completionDate);
	  n.setStatus(status); 
	  n.setReview(review); 
	  n.setRemarks(remarks);
	  taskRepository.save(n);
	   return "Saved"; 
	   }
	 */
	 
	
/*	  @GetMapping(path="/all") public @ResponseBody Iterable<Task> getAllTasks() 
	   {
	  // This returns a JSON or XML with the tasks
	     return taskRepository.findAll();
	   }
 
*/
}
